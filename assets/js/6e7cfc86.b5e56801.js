"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[27926],{63066:e=>{e.exports=JSON.parse('{"functions":[{"name":"promiseNonChatStringForBroadcast","desc":"Returns a filtered string for broadcast. Tends to look like this:\\n\\n```lua\\nTextFilterUtils.promiseNonChatStringForBroadcast(text, player.UserId, Enum.TextFilterContext.PublicChat)\\n\\t:Then(function(filtered)\\n\\t\\tprint(filtered)\\n\\tend)\\n```\\n\\nThe two options for textFilterContext are `Enum.TextFilterContext.PublicChat` and `Enum.TextFilterContext.PrivateChat`.","params":[{"name":"text","desc":"","lua_type":"string"},{"name":"fromUserId","desc":"","lua_type":"number"},{"name":"textFilterContext","desc":"","lua_type":"TextFilterContext"}],"returns":[{"desc":"","lua_type":"Promise<string>"}],"function_type":"static","source":{"line":33,"path":"src/textfilterutils/src/Shared/TextFilterUtils.lua"}},{"name":"promiseLegacyChatFilter","desc":"Legacy filter broadcast using the `Chat:FilterStringForBroadcast` API call. It\'s recommended\\nyou use [TextFilterUtils.promiseNonChatStringForBroadcast] instead.","params":[{"name":"playerFrom","desc":"","lua_type":"Player"},{"name":"text","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"Promise<string>"}],"function_type":"static","source":{"line":54,"path":"src/textfilterutils/src/Shared/TextFilterUtils.lua"}},{"name":"promiseNonChatStringForUserAsync","desc":"Returns a filtered string for a specific user to another user. This is preferable over broadcast if\\npossible.","params":[{"name":"text","desc":"","lua_type":"string"},{"name":"fromUserId","desc":"","lua_type":"number"},{"name":"toUserId","desc":"","lua_type":"number"},{"name":"textFilterContext","desc":"","lua_type":"TextFilterContext"}],"returns":[{"desc":"","lua_type":"Promise<string>"}],"function_type":"static","source":{"line":84,"path":"src/textfilterutils/src/Shared/TextFilterUtils.lua"}},{"name":"getNonChatStringForBroadcastAsync","desc":"Blocking call to get a non-chat string for broadcast. Wraps [TextService.FilterStringAsync].","params":[{"name":"text","desc":"","lua_type":"string"},{"name":"fromUserId","desc":"","lua_type":"number"},{"name":"textFilterContext","desc":"","lua_type":"TextFilterContext"}],"returns":[{"desc":"","lua_type":"Promise<string>"}],"function_type":"static","source":{"line":106,"path":"src/textfilterutils/src/Shared/TextFilterUtils.lua"}},{"name":"getNonChatStringForUserAsync","desc":"Blocking call to get a non-chat string for a user.","params":[{"name":"text","desc":"","lua_type":"string"},{"name":"fromUserId","desc":"","lua_type":"number"},{"name":"toUserId","desc":"","lua_type":"number"},{"name":"textFilterContext","desc":"","lua_type":"TextFilterContext"}],"returns":[{"desc":"","lua_type":"Promise<string>"}],"function_type":"static","source":{"line":137,"path":"src/textfilterutils/src/Shared/TextFilterUtils.lua"}},{"name":"hasNonFilteredText","desc":"Returns true if there\'s non-filtered text or characters in the text","params":[{"name":"text","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"static","source":{"line":183,"path":"src/textfilterutils/src/Shared/TextFilterUtils.lua"}}],"properties":[],"types":[],"name":"TextFilterUtils","desc":"Utility functions for filtering text wrapping [TextService] and legacy [Chat] API surfaces.","source":{"line":6,"path":"src/textfilterutils/src/Shared/TextFilterUtils.lua"}}')}}]);